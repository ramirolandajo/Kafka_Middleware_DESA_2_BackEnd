# Archivo de configuracion minimo
spring.main.banner-mode=${SPRING_MAIN_BANNER_MODE:off}
server.port=${SERVER_PORT:8090}

# Kafka (defaults) - middleware no debe conectar a Kafka por defecto
spring.kafka.bootstrap-servers=${SPRING_KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
spring.kafka.topic.core-events=${SPRING_KAFKA_TOPIC_CORE_EVENTS:core-events}
spring.kafka.consumer.group-id=${SPRING_KAFKA_CONSUMER_GROUP_ID:kafka-middleware-group}

# Modulos autorizados (client ids extraidos del token)
app.authorized-modules=${APP_AUTHORIZED_MODULES:inventory-service,ecommerce-app,analytics-service,analytics-app,analitica-ms,storage-app}

# Enable or disable Kafka usage (middleware debe estar desacoplado por defecto)
app.kafka.enabled=${APP_KAFKA_ENABLED:false}

# Storage type (MEMORY | DATABASE). Puedes override con APP_STORAGE_TYPE
app.storage.type=${APP_STORAGE_TYPE:DATABASE}

# ---- H2 / JPA (persistencia temporal) ----
# Configuración de conexión H2 en memoria:
# - DB_CLOSE_DELAY=-1 mantiene la BD viva mientras la app esté activa.
# - DB_CLOSE_ON_EXIT=FALSE evita cerrarla al finalizar la JVM.
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:h2:mem:middlewaredb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE}
spring.datasource.driverClassName=${SPRING_DATASOURCE_DRIVER_CLASS_NAME:org.h2.Driver}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:sa}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:}

# Hibernate / JPA
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:update}
spring.jpa.show-sql=${SPRING_JPA_SHOW_SQL:true}
spring.jpa.open-in-view=${SPRING_JPA_OPEN_IN_VIEW:false}
spring.jpa.properties.hibernate.jdbc.time_zone=${SPRING_JPA_PROPERTIES_HIBERNATE_JDBC_TIME_ZONE:UTC}

# Logs de SQL
logging.level.org.hibernate.SQL=${LOGGING_LEVEL_ORG_HIBERNATE_SQL:DEBUG}
logging.level.org.hibernate.orm.jdbc.bind=${LOGGING_LEVEL_ORG_HIBERNATE_ORM_JDBC_BIND:TRACE}

# Consola H2 (para inspeccionar la BD)
spring.h2.console.enabled=${SPRING_H2_CONSOLE_ENABLED:true}
spring.h2.console.path=${SPRING_H2_CONSOLE_PATH:/h2-console}

# Logging para verificar modo de persistencia
logging.level.com.example.kafkamiddleware.service.EventStore=${LOGGING_LEVEL_COM_EXAMPLE_KAFKAMIDDLEWARE_SERVICE_EVENTSTORE:DEBUG}

# Keycloak (token endpoint + client credentials - en prod usar vault/vars de entorno)
# Puedes sobrescribir estas propiedades con variables de entorno (KEYCLOAK_URL, KEYCLOAK_REALM, KEYCLOAK_CLIENT_ID, KEYCLOAK_CLIENT_SECRET)
keycloak.token.url=${KEYCLOAK_TOKEN_URL:http://localhost:8080/realms/ecommerce/protocol/openid-connect/token}
keycloak.client-id=${KEYCLOAK_CLIENT_ID:ecommerce-app}
# Para entornos seguros, ponga el client-secret en variables de entorno o en un vault.
keycloak.client-secret=${KEYCLOAK_CLIENT_SECRET:}

# JWKS URI para validar firmas de los tokens (usado por TokenService si existe)
security.jwks-uri=${SECURITY_JWKS_URI:http://localhost:8080/realms/ecommerce/protocol/openid-connect/certs}

# ---- Core forwarding ----
core.api.url=${CORE_API_URL:http://localhost:8082/api}
core.api.resource-path=${CORE_API_RESOURCE_PATH:/core/events}
app.core.forward.enabled=${APP_CORE_FORWARD_ENABLED:true}

# Mapeo de originModule (clientId -> nombre canonico)
app.origin.map=${APP_ORIGIN_MAP:ecommerce-app:Ventas,inventory-service:Inventario,analytics-service:Analitica,analytics-app:Analitica,analitica-ms:Analitica}
